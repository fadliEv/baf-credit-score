package repository

import (
	"baf-credit-score/model"
	"baf-credit-score/repository"
	"errors"
	"testing"
	"time"

	"github.com/DATA-DOG/go-sqlmock"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/suite"
	"gorm.io/driver/postgres"
	"gorm.io/gorm"
)

var dummyCustomers = []model.Customer{
	{
		BaseModel: model.BaseModel{
			ID: "C001",
		},
		FullName:    "Dummy Name 1",
		PhoneNumber: "081234567890",
		NIK:         "1234567890123456",
		Address:     "Dummy Address 1",
		Status:      "active",
		BirthDate:   time.Date(1990, 1, 1, 0, 0, 0, 0, time.UTC),
	},
	{
		BaseModel: model.BaseModel{
			ID: "C002",
		},
		FullName:    "Dummy Name 2",
		PhoneNumber: "081234567891",
		NIK:         "1234567890123457",
		Address:     "Dummy Address 2",
		Status:      "inactive",
		BirthDate:   time.Date(1995, 5, 10, 0, 0, 0, 0, time.UTC),
	},
}

type CustomerRepositoryTestSuite struct {
	suite.Suite	
	mockSql sqlmock.Sqlmock
	repo    repository.CustomerRepository
}

func (suite *CustomerRepositoryTestSuite) SetupTest() {
	db, mock, err := sqlmock.New()
	assert.NoError(suite.T(), err)

	dialect := postgres.New(postgres.Config{
		Conn: db,
	})
	gormDb, _ := gorm.Open(dialect)
	suite.mockSql = mock
	suite.repo = repository.NewCustomerRepository(gormDb)
}

func (suite *CustomerRepositoryTestSuite) TestSave_Success() {
	customer := dummyCustomers[0]

	// GORM akan menyertakan kolom dari BaseModel secara otomatis
	suite.mockSql.ExpectBegin()
	suite.mockSql.ExpectExec(`INSERT INTO "customers"`).
		WithArgs(
			sqlmock.AnyArg(),     // ID (autogenerated)
			sqlmock.AnyArg(),     // CreatedAt (autogenerated)
			sqlmock.AnyArg(),     // UpdatedAt (autogenerated)
			customer.FullName,    // FullName
			customer.PhoneNumber, // PhoneNumber
			customer.NIK,         // NIK
			customer.Address,     // Address
			customer.Status,      // Status
			customer.BirthDate,   // BirthDate
		).WillReturnResult(sqlmock.NewResult(1, 1))
	suite.mockSql.ExpectCommit()

	err := suite.repo.Save(customer)
	assert.Nil(suite.T(), err)
}

func (suite *CustomerRepositoryTestSuite) TestSave_Failed() {
	customer := dummyCustomers[0]

	// GORM akan menyertakan kolom dari BaseModel secara otomatis
	suite.mockSql.ExpectBegin()
	suite.mockSql.ExpectExec(`INSERT INTO "customers"`).
		WithArgs(
			sqlmock.AnyArg(),     // ID (autogenerated)
			sqlmock.AnyArg(),     // CreatedAt (autogenerated)
			sqlmock.AnyArg(),     // UpdatedAt (autogenerated)
			customer.FullName,    // FullName
			customer.PhoneNumber, // PhoneNumber
			customer.NIK,         // NIK
			customer.Address,     // Address
			customer.Status,      // Status
			customer.BirthDate,   // BirthDate
		).WillReturnError(errors.New("failed to insert"))
	suite.mockSql.ExpectRollback()

	err := suite.repo.Save(customer)
	assert.Error(suite.T(), err)
	assert.Equal(suite.T(), "failed to insert", err.Error())
}

func (suite *CustomerRepositoryTestSuite) TestGet_Success() {
	customer := dummyCustomers[0]

	// Buat mock row untuk data customer
	rows := sqlmock.NewRows([]string{"id", "full_name", "phone_number", "nik", "address", "status", "birth_date"}).
		AddRow(customer.ID, customer.FullName, customer.PhoneNumber, customer.NIK, customer.Address, customer.Status, customer.BirthDate)

	// Perbaiki regex dan tambahkan parameter LIMIT ($2)
	suite.mockSql.ExpectQuery(`SELECT \* FROM "customers" WHERE "id" = \$1 ORDER BY "customers"."id" LIMIT \$2`).
		WithArgs(customer.ID, 1).WillReturnRows(rows)

	// Panggil repository
	result, err := suite.repo.Get(customer.ID)

	// Assertion
	assert.Nil(suite.T(), err)
	assert.NotNil(suite.T(), result)
	assert.Equal(suite.T(), customer.FullName, result.FullName)
}

func (suite *CustomerRepositoryTestSuite) TestGet_Failed() {
	// Update regex untuk mencocokkan query GORM dengan parameter LIMIT ($2)
	suite.mockSql.ExpectQuery(`SELECT \* FROM "customers" WHERE "id" = \$1 ORDER BY "customers"."id" LIMIT \$2`).
		WithArgs("invalid_id", 1).WillReturnError(errors.New("record not found"))

	// Panggil repository dengan ID yang tidak valid
	_, err := suite.repo.Get("invalid_id")

	// Assertion
	assert.Error(suite.T(), err)
	assert.Equal(suite.T(), "record not found", err.Error())
}

func (suite *CustomerRepositoryTestSuite) TestList_Success() {
	rows := sqlmock.NewRows([]string{"id", "full_name", "phone_number", "nik", "address", "status", "birth_date"})
	for _, customer := range dummyCustomers {
		rows.AddRow(customer.ID, customer.FullName, customer.PhoneNumber, customer.NIK, customer.Address, customer.Status, customer.BirthDate)
	}

	suite.mockSql.ExpectQuery(`SELECT \* FROM "customers"`).WillReturnRows(rows)

	customers, err := suite.repo.List()
	assert.Nil(suite.T(), err)
	assert.Equal(suite.T(), len(dummyCustomers), len(customers))
}

func (suite *CustomerRepositoryTestSuite) TestList_Failed() {
	// Update regex untuk mencocokkan query GORM
	suite.mockSql.ExpectQuery(`SELECT \* FROM "customers"`).
		WillReturnError(errors.New("query failed"))

	// Panggil repository
	customers, err := suite.repo.List()

	// Assertion
	assert.Nil(suite.T(), customers)
	assert.Error(suite.T(), err)
	assert.Equal(suite.T(), "query failed", err.Error())
}

func (suite *CustomerRepositoryTestSuite) TestDelete_Success() {
	suite.mockSql.ExpectBegin()
	suite.mockSql.ExpectExec(`DELETE FROM "customers" WHERE id = \$1`).WithArgs("C001").WillReturnResult(sqlmock.NewResult(0, 1))
	suite.mockSql.ExpectCommit()

	err := suite.repo.Delete("C001")
	assert.Nil(suite.T(), err)
}

func (suite *CustomerRepositoryTestSuite) TestDelete_Failed() {
	suite.mockSql.ExpectBegin()
	suite.mockSql.ExpectExec(`DELETE FROM "customers" WHERE id = \$1`).WithArgs("C001").WillReturnError(errors.New("failed to delete"))
	suite.mockSql.ExpectRollback()

	err := suite.repo.Delete("C001")
	assert.Error(suite.T(), err)
	assert.Equal(suite.T(), "failed to delete", err.Error())
}

func (suite *CustomerRepositoryTestSuite) TestUpdate_Success() {
	customer := dummyCustomers[0]
	customer.FullName = "Updated Name"
	customer.Address = "Updated Address"

	// Mock query untuk update
	suite.mockSql.ExpectBegin()
	suite.mockSql.ExpectExec(`UPDATE "customers" SET`).
		WithArgs(			
			sqlmock.AnyArg(),     // CreatedAt (autogenerated)
			sqlmock.AnyArg(),     // UpdatedAt (autogenerated)
			customer.FullName,    // FullName
			customer.PhoneNumber, // PhoneNumber
			customer.NIK,         // NIK
			customer.Address,     // Address
			customer.Status,      // Status
			customer.BirthDate,   // BirthDate	
			sqlmock.AnyArg(),     // ID (autogenerated)		
		).WillReturnResult(sqlmock.NewResult(0, 1)) // Sukses, 1 baris terpengaruh
	suite.mockSql.ExpectCommit()

	// Panggil repository
	err := suite.repo.Update(customer)

	// Assertion
	assert.Nil(suite.T(), err)
}

func (suite *CustomerRepositoryTestSuite) TestUpdate_Failed() {
	customer := dummyCustomers[0]
	customer.FullName = "Updated Name"
	customer.Address = "Updated Address"

	// Mock query untuk gagal update
	suite.mockSql.ExpectBegin()
	suite.mockSql.ExpectExec(`UPDATE "customers" SET`).
		WithArgs(
			sqlmock.AnyArg(),     // CreatedAt (autogenerated)
			sqlmock.AnyArg(),     // UpdatedAt (autogenerated)
			customer.FullName,    // FullName
			customer.PhoneNumber, // PhoneNumber
			customer.NIK,         // NIK
			customer.Address,     // Address
			customer.Status,      // Status
			customer.BirthDate,   // BirthDate	
			sqlmock.AnyArg(),     // ID (autogenerated)		
		).WillReturnError(errors.New("update failed")) // Simulasi error
	suite.mockSql.ExpectRollback()

	// Panggil repository
	err := suite.repo.Update(customer)

	// Assertion
	assert.Error(suite.T(), err)
	assert.Equal(suite.T(), "update failed", err.Error())
}

func TestCustomerRepositoryTestSuite(t *testing.T) {
	suite.Run(t, new(CustomerRepositoryTestSuite))
}
